Args: ../builddir/bin/llc -march=frisc strlen.ll -debug 
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
	discovered a new reachable node %13
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
	discovered a new reachable node %13
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
	discovered a new reachable node %13
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
	discovered a new reachable node %13
---- Branch Probability Info : strlen ----

Computing probabilities for 
Computing probabilities for 
Computing probabilities for 
set edge  -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge  -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for 

block-frequency: strlen
=======================
reverse-post-order-traversal
 - 0: 
 - 1: 
 - 2: 
 - 3: 
loop-detection
 - loop = 
 - loop = : member = 
compute-mass-in-loop: *
 - node: 
  => [ local  ] weight = 2080374784, succ = 
  => [  exit  ] weight = 67108864, succ = 
  => mass:  ffffffffffffffff
  => assign 07ffffffffffffff (f800000000000000) [exit] to 
  => assign f800000000000000 (0000000000000000) to 
 - node: 
  => [backedge] weight = 2147483648
  => mass:  f800000000000000
  => assign f800000000000000 (0000000000000000) [back] to 
compute-loop-scale: *
 - exit-mass = 07ffffffffffffff (ffffffffffffffff - f800000000000000)
 - scale = 32.0
packaging-loop: *
 - node: 
 - node: 
compute-mass-in-function
 - node: 
  => [ local  ] weight = 2147483648, succ = 
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to 
 - node: 
  => [ local  ] weight = 576460752303423487, succ = 
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to 
 - node: 
  => mass:  ffffffffffffffff
unwrap-loop-package: *: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - : 1.0 => 32.0
 - : 0.96875 => 31.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - : float = 1.0, scaled = 8.0, int = 8
 - : float = 32.0, scaled = 256.0, int = 256
 - : float = 1.0, scaled = 8.0, int = 8
 - : float = 31.0, scaled = 248.0, int = 248
block-frequency-info: strlen
 - : float = 1.0, int = 8
 - : float = 32.0, int = 256
 - : float = 31.0, int = 248
 - : float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: strlen
********** End Constant Hoisting **********
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
	discovered a new reachable node %13
MERGING MOSTLY EMPTY BLOCKS - BEFORE:

; <label>:12:                                     ; preds = %4
  br label %4

; <label>:4:                                      ; preds = %12, %1
  %5 = load i8*, i8** %2, align 4
  %6 = load i32, i32* %3, align 4
  %7 = add nsw i32 %6, 1
  store i32 %7, i32* %3, align 4
  %8 = getelementptr inbounds i8, i8* %5, i32 %6
  %9 = load i8, i8* %8, align 1
  %10 = sext i8 %9 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %12, label %13
AFTER:

; <label>:4:                                      ; preds = %4, %1
  %5 = load i8*, i8** %2, align 4
  %6 = load i32, i32* %3, align 4
  %7 = add nsw i32 %6, 1
  store i32 %7, i32* %3, align 4
  %8 = getelementptr inbounds i8, i8* %5, i32 %6
  %9 = load i8, i8* %8, align 1
  %10 = sext i8 %9 to i32
  %11 = icmp ne i32 %10, 0
  br i1 %11, label %4, label %12



CGP: Found      local addrmode: [Base:%2]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%2]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%3]
CGP: Found      local addrmode: [Base:%5 + 1*%6]
CGP: Found      local addrmode: [Base:%3]
[SafeStack] Function: strlen
[SafeStack]     safestack is not requested for this function
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
	discovered a new reachable node %1
	discovered a new reachable node %4
	discovered a new reachable node %12
---- Branch Probability Info : strlen ----

Computing probabilities for 
Computing probabilities for 
set edge  -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge  -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for 



=== strlen
Found argument copy elision candidate:   %2 = alloca i8*, align 4
Initial selection DAG: BB#0 'strlen:'
SelectionDAG has 9 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0
    t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32
  t8: ch = store<ST4[%3]> t6, Constant:i32<0>, FrameIndex:i32<1>, undef:i32



Combining: t8: ch = store<ST4[%3]> t6, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

Replacing.1 t8: ch = store<ST4[%3]> t6, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

With: t10: ch = TokenFactor t6, t9
 and 0 other values

Combining: t10: ch = TokenFactor t6, t9

Combining: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

Combining: t7: i32 = FrameIndex<1>

Combining: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

Combining: t5: i32 = undef

Combining: t4: i32 = Constant<0>

Combining: t3: i32 = FrameIndex<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Combining: t1: i32 = Register %vreg0

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: BB#0 'strlen:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0
    t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32
    t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32
  t10: ch = TokenFactor t6, t9


Legally typed node: t7: i32 = FrameIndex<1>

Legally typed node: t5: i32 = undef

Legally typed node: t4: i32 = Constant<0>

Legally typed node: t3: i32 = FrameIndex<0>

Legally typed node: t1: i32 = Register %vreg0

Legally typed node: t0: ch = EntryToken

Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Legally typed node: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

Legally typed node: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

Legally typed node: t10: ch = TokenFactor t6, t9

Legally typed node: t65535: ch = handlenode t10

Type-legalized selection DAG: BB#0 'strlen:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0
    t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32
    t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32
  t10: ch = TokenFactor t6, t9



Legalizing: t10: ch = TokenFactor t6, t9

Legalizing: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

Legalizing: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Legalizing: t7: i32 = FrameIndex<1>

Legalizing: t5: i32 = undef

Legalizing: t4: i32 = Constant<0>

Legalizing: t3: i32 = FrameIndex<0>

Legalizing: t1: i32 = Register %vreg0

Legalizing: t0: ch = EntryToken
Legalized selection DAG: BB#0 'strlen:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0
    t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32
    t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32
  t10: ch = TokenFactor t6, t9



Legalizing: t10: ch = TokenFactor t6, t9

Combining: t10: ch = TokenFactor t6, t9

Legalizing: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

Combining: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

Legalizing: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

Combining: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Legalizing: t7: i32 = FrameIndex<1>

Combining: t7: i32 = FrameIndex<1>

Legalizing: t5: i32 = undef

Combining: t5: i32 = undef

Legalizing: t4: i32 = Constant<0>

Combining: t4: i32 = Constant<0>

Legalizing: t3: i32 = FrameIndex<0>

Combining: t3: i32 = FrameIndex<0>

Legalizing: t1: i32 = Register %vreg0

Combining: t1: i32 = Register %vreg0

Legalizing: t0: ch = EntryToken

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: BB#0 'strlen:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0
    t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32
    t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32
  t10: ch = TokenFactor t6, t9


===== Instruction selection begins: BB#0 ''
Selecting: t10: ch = TokenFactor t6, t9

Selecting: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

ISEL: Starting pattern match on root node: t6: ch = store<ST4[%2]> t0, t2, FrameIndex:i32<0>, undef:i32

  Match failed at index 9
  Continuing at 64
  Skipped scope entry (due to false predicate) at index 73, continuing at 107
  Morphed node: t6: ch = STORE_ri<Mem:ST4[%2]> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t2, t0

ISEL: Match complete!
Selecting: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

ISEL: Starting pattern match on root node: t9: ch = store<ST4[%3]> t0, Constant:i32<0>, FrameIndex:i32<1>, undef:i32

  Initial Opcode index to 4
  Match failed at index 9
  Continuing at 64
  Skipped scope entry (due to false predicate) at index 73, continuing at 107
  Morphed node: t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, Constant:i32<0>, t0

ISEL: Match complete!
Selecting: t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Selecting: t4: i32 = Constant<0>

ISEL: Starting pattern match on root node: t4: i32 = Constant<0>

  Initial Opcode index to 958
  Morphed node: t4: i32 = MOVE_ri TargetConstant:i32<0>

ISEL: Match complete!
Selecting: t1: i32 = Register %vreg0

Selecting: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#0 'strlen:'
SelectionDAG has 10 nodes:
  t0: ch = EntryToken
      t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0
    t6: ch = STORE_ri<Mem:ST4[%2]> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t2, t0
      t4: i32 = MOVE_ri TargetConstant:i32<0>
    t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0
  t10: ch = TokenFactor t6, t9


********** List Scheduling BB#0 '' **********
SU(0): t10: ch = TokenFactor t6, t9

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
    SU(1): Ord  Latency=1 Barrier
SU(1): t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t4: i32 = MOVE_ri TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t6: ch = STORE_ri<Mem:ST4[%2]> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t2, t0

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(3): Data Latency=1

Examining Available:
Height 0: SU(0): t10: ch = TokenFactor t6, t9


*** Scheduling [0]: SU(0): t10: ch = TokenFactor t6, t9


Examining Available:
Height 1: SU(3): t6: ch = STORE_ri<Mem:ST4[%2]> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t2, t0

Height 1: SU(1): t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0


*** Scheduling [1]: SU(3): t6: ch = STORE_ri<Mem:ST4[%2]> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t2, t0

GPR: 1 / 0

Examining Available:
RegPressureDiff SU(1): 1 != SU(4): 0
Height 2: SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

Height 1: SU(1): t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0

RegPressureDiff SU(1): 1 != SU(4): 0

*** Scheduling [2]: SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0


Examining Available:
Height 1: SU(1): t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0


*** Scheduling [3]: SU(1): t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0

GPR: 1 / 0

Examining Available:
Height 4: SU(2): t4: i32 = MOVE_ri TargetConstant:i32<0>


*** Scheduling [4]: SU(2): t4: i32 = MOVE_ri TargetConstant:i32<0>

*** Final schedule ***
SU(2): t4: i32 = MOVE_ri TargetConstant:i32<0>

SU(1): t9: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t4, t0

SU(4): t2: i32,ch = CopyFromReg t0, Register:i32 %vreg0

SU(3): t6: ch = STORE_ri<Mem:ST4[%2]> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t2, t0

SU(0): t10: ch = TokenFactor t6, t9


Total amount of phi nodes to update: 0
Initial selection DAG: BB#1 'strlen:'
SelectionDAG has 20 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32
  t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
    t9: ch = TokenFactor t4:1, t6:1
    t8: i32 = add t6, Constant:i32<1>
  t10: ch = store<ST4[%3]> t9, t8, FrameIndex:i32<1>, undef:i32
            t11: i32 = add t4, t6
          t12: i8,ch = load<LD1[%8]> t10, t11, undef:i32
        t13: i32 = sign_extend t12
      t15: i1 = setcc t13, Constant:i32<0>, setne:ch
    t17: ch = brcond t10, t15, BasicBlock:ch< 0x4afa818>
  t19: ch = br t17, BasicBlock:ch< 0x4afa8c8>



Combining: t19: ch = br t17, BasicBlock:ch< 0x4afa8c8>

Combining: t18: ch = BasicBlock< 0x4afa8c8>

Combining: t17: ch = brcond t10, t15, BasicBlock:ch< 0x4afa818>
 ... into: t20: ch = br_cc t10, setne:ch, t13, Constant:i32<0>, BasicBlock:ch< 0x4afa818>

Combining: t19: ch = br t20, BasicBlock:ch< 0x4afa8c8>

Combining: t20: ch = br_cc t10, setne:ch, t13, Constant:i32<0>, BasicBlock:ch< 0x4afa818>

Combining: t16: ch = BasicBlock< 0x4afa818>

Combining: t14: ch = setne

Combining: t13: i32 = sign_extend t12

Replacing.1 t13: i32 = sign_extend t12

With: t21: i32,ch = load<LD1[%8], sext from i8> t10, t11, undef:i32
 and 0 other values

Combining: t20: ch = br_cc t10, setne:ch, t21, Constant:i32<0>, BasicBlock:ch< 0x4afa818>

Combining: t21: i32,ch = load<LD1[%8], sext from i8> t10, t11, undef:i32

Combining: t11: i32 = add t4, t6

Combining: t10: ch = store<ST4[%3]> t9, t8, FrameIndex:i32<1>, undef:i32

Replacing.1 t10: ch = store<ST4[%3]> t9, t8, FrameIndex:i32<1>, undef:i32

With: t24: ch = TokenFactor t9, t23
 and 0 other values

Combining: t24: ch = TokenFactor t9, t23
 ... into: t25: ch = TokenFactor t23, t4:1

Combining: t20: ch = br_cc t25, setne:ch, t21, Constant:i32<0>, BasicBlock:ch< 0x4afa818>

Combining: t21: i32,ch = load<LD1[%8], sext from i8> t25, t11, undef:i32

Replacing.1 t21: i32,ch = load<LD1[%8], sext from i8> t25, t11, undef:i32

With: t26: i32,ch = load<LD1[%8], sext from i8> t23, t11, undef:i32
 and 1 other values

Combining: t20: ch = br_cc t25, setne:ch, t26, Constant:i32<0>, BasicBlock:ch< 0x4afa818>

Combining: t26: i32,ch = load<LD1[%8], sext from i8> t23, t11, undef:i32

Combining: t25: ch = TokenFactor t23, t4:1

Combining: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

Combining: t8: i32 = add t6, Constant:i32<1>

Combining: t7: i32 = Constant<1>

Combining: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Combining: t5: i32 = FrameIndex<1>

Combining: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

Combining: t3: i32 = undef

Combining: t2: i32 = Constant<0>

Combining: t1: i32 = FrameIndex<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: BB#1 'strlen:'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32
  t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
    t8: i32 = add t6, Constant:i32<1>
  t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32
      t25: ch = TokenFactor t23, t4:1
        t11: i32 = add t4, t6
      t26: i32,ch = load<LD1[%8], sext from i8> t23, t11, undef:i32
    t20: ch = br_cc t25, setne:ch, t26, Constant:i32<0>, BasicBlock:ch< 0x4afa818>
  t19: ch = br t20, BasicBlock:ch< 0x4afa8c8>


Legally typed node: t18: ch = BasicBlock< 0x4afa8c8>

Legally typed node: t16: ch = BasicBlock< 0x4afa818>

Legally typed node: t14: ch = setne

Legally typed node: t7: i32 = Constant<1>

Legally typed node: t5: i32 = FrameIndex<1>

Legally typed node: t3: i32 = undef

Legally typed node: t2: i32 = Constant<0>

Legally typed node: t1: i32 = FrameIndex<0>

Legally typed node: t0: ch = EntryToken

Legally typed node: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

Legally typed node: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Legally typed node: t8: i32 = add t6, Constant:i32<1>

Legally typed node: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

Legally typed node: t25: ch = TokenFactor t23, t4:1

Legally typed node: t11: i32 = add t4, t6

Legally typed node: t26: i32,ch = load<LD1[%8], sext from i8> t23, t11, undef:i32

Legally typed node: t20: ch = br_cc t25, setne:ch, t26, Constant:i32<0>, BasicBlock:ch< 0x4afa818>

Legally typed node: t19: ch = br t20, BasicBlock:ch< 0x4afa8c8>

Legally typed node: t65535: ch = handlenode t19

Type-legalized selection DAG: BB#1 'strlen:'
SelectionDAG has 18 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32
  t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
    t8: i32 = add t6, Constant:i32<1>
  t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32
      t25: ch = TokenFactor t23, t4:1
        t11: i32 = add t4, t6
      t26: i32,ch = load<LD1[%8], sext from i8> t23, t11, undef:i32
    t20: ch = br_cc t25, setne:ch, t26, Constant:i32<0>, BasicBlock:ch< 0x4afa818>
  t19: ch = br t20, BasicBlock:ch< 0x4afa8c8>



Legalizing: t19: ch = br t20, BasicBlock:ch< 0x4afa8c8>

Legalizing: t20: ch = br_cc t25, setne:ch, t26, Constant:i32<0>, BasicBlock:ch< 0x4afa818>
 ... replacing: t20: ch = br_cc t25, setne:ch, t26, Constant:i32<0>, BasicBlock:ch< 0x4afa818>
     with:      t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29

Legalizing: t25: ch = TokenFactor t23, t4:1

Legalizing: t26: i32,ch = load<LD1[%8], sext from i8> t23, t11, undef:i32

Legalizing: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

Legalizing: t8: i32 = add t6, Constant:i32<1>

Legalizing: t11: i32 = add t4, t6

Legalizing: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Legalizing: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

Legalizing: t18: ch = BasicBlock< 0x4afa8c8>

Legalizing: t16: ch = BasicBlock< 0x4afa818>

Legalizing: t7: i32 = Constant<1>

Legalizing: t5: i32 = FrameIndex<1>

Legalizing: t3: i32 = undef

Legalizing: t2: i32 = Constant<0>

Legalizing: t1: i32 = FrameIndex<0>

Legalizing: t0: ch = EntryToken

Legalizing: t33: i32 = sign_extend_inreg t31, ValueType:ch:i8
 ... replacing: t33: i32 = sign_extend_inreg t31, ValueType:ch:i8
     with:      t36: i32 = sra t35, Constant:i32<24>

Legalizing: t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32

Legalizing: t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29

Legalizing: t29: glue = FRISCISD::CMP t36, Constant:i32<0>

Legalizing: t28: i32 = Constant<8>

Legalizing: t36: i32 = sra t35, Constant:i32<24>

Legalizing: t35: i32 = shl t31, Constant:i32<24>

Legalizing: t34: i32 = Constant<24>
Legalized selection DAG: BB#1 'strlen:'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32
  t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
    t8: i32 = add t6, Constant:i32<1>
  t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32
      t25: ch = TokenFactor t23, t4:1
              t11: i32 = add t4, t6
            t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32
          t35: i32 = shl t31, Constant:i32<24>
        t36: i32 = sra t35, Constant:i32<24>
      t29: glue = FRISCISD::CMP t36, Constant:i32<0>
    t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29
  t19: ch = br t30, BasicBlock:ch< 0x4afa8c8>



Legalizing: t36: i32 = sra t35, Constant:i32<24>

Combining: t36: i32 = sra t35, Constant:i32<24>

Legalizing: t35: i32 = shl t31, Constant:i32<24>

Combining: t35: i32 = shl t31, Constant:i32<24>

Legalizing: t34: i32 = Constant<24>

Combining: t34: i32 = Constant<24>

Legalizing: t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32

Combining: t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32

Legalizing: t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29

Combining: t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29

Legalizing: t29: glue = FRISCISD::CMP t36, Constant:i32<0>

Combining: t29: glue = FRISCISD::CMP t36, Constant:i32<0>

Legalizing: t28: i32 = Constant<8>

Combining: t28: i32 = Constant<8>

Legalizing: t19: ch = br t30, BasicBlock:ch< 0x4afa8c8>

Combining: t19: ch = br t30, BasicBlock:ch< 0x4afa8c8>

Legalizing: t25: ch = TokenFactor t23, t4:1

Combining: t25: ch = TokenFactor t23, t4:1

Legalizing: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

Combining: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

Legalizing: t8: i32 = add t6, Constant:i32<1>

Combining: t8: i32 = add t6, Constant:i32<1>

Legalizing: t11: i32 = add t4, t6

Combining: t11: i32 = add t4, t6

Legalizing: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Combining: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Legalizing: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

Combining: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

Legalizing: t18: ch = BasicBlock< 0x4afa8c8>

Combining: t18: ch = BasicBlock< 0x4afa8c8>

Legalizing: t16: ch = BasicBlock< 0x4afa818>

Combining: t16: ch = BasicBlock< 0x4afa818>

Legalizing: t7: i32 = Constant<1>

Combining: t7: i32 = Constant<1>

Legalizing: t5: i32 = FrameIndex<1>

Combining: t5: i32 = FrameIndex<1>

Legalizing: t3: i32 = undef

Combining: t3: i32 = undef

Legalizing: t2: i32 = Constant<0>

Combining: t2: i32 = Constant<0>

Legalizing: t1: i32 = FrameIndex<0>

Combining: t1: i32 = FrameIndex<0>

Legalizing: t0: ch = EntryToken

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: BB#1 'strlen:'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32
  t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
    t8: i32 = add t6, Constant:i32<1>
  t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32
      t25: ch = TokenFactor t23, t4:1
              t11: i32 = add t4, t6
            t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32
          t35: i32 = shl t31, Constant:i32<24>
        t36: i32 = sra t35, Constant:i32<24>
      t29: glue = FRISCISD::CMP t36, Constant:i32<0>
    t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29
  t19: ch = br t30, BasicBlock:ch< 0x4afa8c8>


===== Instruction selection begins: BB#1 ''
Selecting: t19: ch = br t30, BasicBlock:ch< 0x4afa8c8>

ISEL: Starting pattern match on root node: t19: ch = br t30, BasicBlock:ch< 0x4afa8c8>

  Initial Opcode index to 930
  Morphed node: t19: ch = JP_i BasicBlock:ch< 0x4afa8c8>, t30

ISEL: Match complete!
Selecting: t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29

ISEL: Starting pattern match on root node: t30: ch = FRISCISD::BR_CC t25, BasicBlock:ch< 0x4afa818>, Constant:i32<8>, t29

  Initial Opcode index to 728
  Morphed node: t30: ch = JPcc_i BasicBlock:ch< 0x4afa818>, TargetConstant:i32<8>, t25, t29

ISEL: Match complete!
Selecting: t29: glue = FRISCISD::CMP t36, Constant:i32<0>

ISEL: Starting pattern match on root node: t29: glue = FRISCISD::CMP t36, Constant:i32<0>

  Initial Opcode index to 861
  Morphed node: t29: i32,glue = CMP_rr t36, Constant:i32<0>

ISEL: Match complete!
Selecting: t36: i32 = sra t35, Constant:i32<24>

ISEL: Starting pattern match on root node: t36: i32 = sra t35, Constant:i32<24>

  Initial Opcode index to 694
  Morphed node: t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>

ISEL: Match complete!
Selecting: t35: i32 = shl t31, Constant:i32<24>

ISEL: Starting pattern match on root node: t35: i32 = shl t31, Constant:i32<24>

  Initial Opcode index to 626
  Morphed node: t35: i32,i32 = SHL_ri t31, TargetConstant:i32<24>

ISEL: Match complete!
Selecting: t25: ch = TokenFactor t23, t4:1

Selecting: t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32

ISEL: Starting pattern match on root node: t31: i32,ch = load<LD1[%8], anyext from i8> t23, t11, undef:i32

  Initial Opcode index to 127
  Morphed node: t31: i32,ch = LOADB_ri<Mem:LD1[%8]> t11, TargetConstant:i32<0>, t23

ISEL: Match complete!
Selecting: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

ISEL: Starting pattern match on root node: t23: ch = store<ST4[%3]> t6:1, t8, FrameIndex:i32<1>, undef:i32

  Initial Opcode index to 4
  Match failed at index 9
  Continuing at 64
  Skipped scope entry (due to false predicate) at index 73, continuing at 107
  Morphed node: t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1

ISEL: Match complete!
Selecting: t8: i32 = add t6, Constant:i32<1>

ISEL: Starting pattern match on root node: t8: i32 = add t6, Constant:i32<1>

  Initial Opcode index to 240
  Match failed at index 244
  Continuing at 279
  Match failed at index 281
  Continuing at 318
  Morphed node: t8: i32,i32 = ADD_ri t6, TargetConstant:i32<1>

ISEL: Match complete!
Selecting: t11: i32 = add t4, t6

ISEL: Starting pattern match on root node: t11: i32 = add t4, t6

  Initial Opcode index to 240
  Match failed at index 244
  Continuing at 279
  Match failed at index 281
  Continuing at 318
  Match failed at index 324
  Continuing at 339
  Morphed node: t11: i32,i32 = ADD_rr t4, t6

ISEL: Match complete!
Selecting: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

ISEL: Starting pattern match on root node: t6: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

  Initial Opcode index to 127
  Skipped scope entry (due to false predicate) at index 136, continuing at 170
  Morphed node: t6: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

ISEL: Match complete!
Selecting: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

ISEL: Starting pattern match on root node: t4: i32,ch = load<LD4[%2](dereferenceable)> t0, FrameIndex:i32<0>, undef:i32

  Initial Opcode index to 127
  Skipped scope entry (due to false predicate) at index 136, continuing at 170
  Morphed node: t4: i32,ch = LOAD_ri<Mem:LD4[%2](dereferenceable)> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0

ISEL: Match complete!
Selecting: t18: ch = BasicBlock< 0x4afa8c8>

Selecting: t16: ch = BasicBlock< 0x4afa818>

Selecting: t2: i32 = Constant<0>

ISEL: Starting pattern match on root node: t2: i32 = Constant<0>

  Initial Opcode index to 958
  Morphed node: t2: i32 = MOVE_ri TargetConstant:i32<0>

ISEL: Match complete!
Selecting: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#1 'strlen:'
SelectionDAG has 22 nodes:
  t0: ch = EntryToken
  t4: i32,ch = LOAD_ri<Mem:LD4[%2](dereferenceable)> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0
  t6: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0
    t8: i32,i32 = ADD_ri t6, TargetConstant:i32<1>
  t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1
      t25: ch = TokenFactor t23, t4:1
              t11: i32,i32 = ADD_rr t4, t6
            t31: i32,ch = LOADB_ri<Mem:LD1[%8]> t11, TargetConstant:i32<0>, t23
          t35: i32,i32 = SHL_ri t31, TargetConstant:i32<24>
        t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>
        t2: i32 = MOVE_ri TargetConstant:i32<0>
      t29: i32,glue = CMP_rr t36, t2
    t30: ch = JPcc_i BasicBlock:ch< 0x4afa818>, TargetConstant:i32<8>, t25, t29:1
  t19: ch = JP_i BasicBlock:ch< 0x4afa8c8>, t30


********** List Scheduling BB#1 '' **********
SU(0): t19: ch = JP_i BasicBlock:ch< 0x4afa8c8>, t30

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t30: ch = JPcc_i BasicBlock:ch< 0x4afa818>, TargetConstant:i32<8>, t25, t29:1

    t29: i32,glue = CMP_rr t36, t2

  # preds left       : 3
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 1
  Predecessors:
    SU(11): Ord  Latency=0 Barrier
    SU(3): Data Latency=1
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t2: i32 = MOVE_ri TargetConstant:i32<0>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
  Successors:
    SU(1): Data Latency=1
SU(4): t35: i32,i32 = SHL_ri t31, TargetConstant:i32<24>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(3): Data Latency=1
SU(5): t31: i32,ch = LOADB_ri<Mem:LD1[%8]> t11, TargetConstant:i32<0>, t23

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(9): Data Latency=1
    SU(6): Ord  Latency=1 Barrier
  Successors:
    SU(4): Data Latency=1
SU(6): t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 5
  Predecessors:
    SU(8): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
  Successors:
    SU(5): Ord  Latency=1 Barrier
    SU(11): Ord  Latency=1 Barrier
SU(7): t6: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(6): Ord  Latency=1 Barrier
    SU(8): Data Latency=1
    SU(9): Data Latency=1
SU(8): t8: i32,i32 = ADD_ri t6, TargetConstant:i32<1>

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 6
  Predecessors:
    SU(7): Data Latency=1
  Successors:
    SU(6): Data Latency=1
SU(9): t11: i32,i32 = ADD_rr t4, t6

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(10): Data Latency=1
    SU(7): Data Latency=1
  Successors:
    SU(5): Data Latency=1
SU(10): t4: i32,ch = LOAD_ri<Mem:LD4[%2](dereferenceable)> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 6
  Successors:
    SU(9): Data Latency=1
    SU(11): Ord  Latency=1 Barrier
SU(11): t25: ch = TokenFactor t23, t4:1

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(6): Ord  Latency=1 Barrier
    SU(10): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier

Examining Available:
Height 0: SU(0): t19: ch = JP_i BasicBlock:ch< 0x4afa8c8>, t30


*** Scheduling [0]: SU(0): t19: ch = JP_i BasicBlock:ch< 0x4afa8c8>, t30


Examining Available:
Height 1: SU(1): t30: ch = JPcc_i BasicBlock:ch< 0x4afa818>, TargetConstant:i32<8>, t25, t29:1

    t29: i32,glue = CMP_rr t36, t2


*** Scheduling [1]: SU(1): t30: ch = JPcc_i BasicBlock:ch< 0x4afa818>, TargetConstant:i32<8>, t25, t29:1

    t29: i32,glue = CMP_rr t36, t2

GPR: 2 / 0

Examining Available:
Height 1: SU(11): t25: ch = TokenFactor t23, t4:1

RegPressureDiff SU(2): -1 != SU(3): 0
Height 2: SU(2): t2: i32 = MOVE_ri TargetConstant:i32<0>

Height 2: SU(3): t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>


*** Scheduling [2]: SU(11): t25: ch = TokenFactor t23, t4:1

GPR: 2 / 0

Examining Available:
RegPressureDiff SU(2): -1 != SU(3): 0
Height 2: SU(2): t2: i32 = MOVE_ri TargetConstant:i32<0>

Height 2: SU(3): t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>

RegPressureDiff SU(2): -1 != SU(3): 0

*** Scheduling [3]: SU(2): t2: i32 = MOVE_ri TargetConstant:i32<0>

GPR: 1 / 0

Examining Available:
Height 2: SU(3): t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>


*** Scheduling [4]: SU(3): t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>

GPR: 1 / 0

Examining Available:
Height 5: SU(4): t35: i32,i32 = SHL_ri t31, TargetConstant:i32<24>


*** Scheduling [5]: SU(4): t35: i32,i32 = SHL_ri t31, TargetConstant:i32<24>

GPR: 1 / 0

Examining Available:
Height 6: SU(5): t31: i32,ch = LOADB_ri<Mem:LD1[%8]> t11, TargetConstant:i32<0>, t23


*** Scheduling [6]: SU(5): t31: i32,ch = LOADB_ri<Mem:LD1[%8]> t11, TargetConstant:i32<0>, t23

GPR: 1 / 0

Examining Available:
Height 7: SU(9): t11: i32,i32 = ADD_rr t4, t6

Height 7: SU(6): t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1


*** Scheduling [7]: SU(9): t11: i32,i32 = ADD_rr t4, t6

GPR: 2 / 0

Examining Available:
RegPressureDiff SU(6): 1 != SU(10): -1
Height 8: SU(10): t4: i32,ch = LOAD_ri<Mem:LD4[%2](dereferenceable)> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0

Height 7: SU(6): t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1

RegPressureDiff SU(6): 1 != SU(10): -1

*** Scheduling [8]: SU(10): t4: i32,ch = LOAD_ri<Mem:LD4[%2](dereferenceable)> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0

GPR: 1 / 0

Examining Available:
Height 7: SU(6): t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1


*** Scheduling [9]: SU(6): t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1

GPR: 2 / 0

Examining Available:
Height 10: SU(8): t8: i32,i32 = ADD_ri t6, TargetConstant:i32<1>


*** Scheduling [10]: SU(8): t8: i32,i32 = ADD_ri t6, TargetConstant:i32<1>

GPR: 1 / 0

Examining Available:
Height 11: SU(7): t6: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0


*** Scheduling [11]: SU(7): t6: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(7): t6: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

SU(8): t8: i32,i32 = ADD_ri t6, TargetConstant:i32<1>

SU(6): t23: ch = STORE_ri<Mem:ST4[%3]> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t8, t6:1

SU(10): t4: i32,ch = LOAD_ri<Mem:LD4[%2](dereferenceable)> TargetFrameIndex:i32<0>, TargetConstant:i32<0>, t0

SU(9): t11: i32,i32 = ADD_rr t4, t6

SU(5): t31: i32,ch = LOADB_ri<Mem:LD1[%8]> t11, TargetConstant:i32<0>, t23

SU(4): t35: i32,i32 = SHL_ri t31, TargetConstant:i32<24>

SU(3): t36: i32,i32 = ASHR_ri t35, TargetConstant:i32<24>

SU(2): t2: i32 = MOVE_ri TargetConstant:i32<0>

SU(11): t25: ch = TokenFactor t23, t4:1

SU(1): t30: ch = JPcc_i BasicBlock:ch< 0x4afa818>, TargetConstant:i32<8>, t25, t29:1

    t29: i32,glue = CMP_rr t36, t2

SU(0): t19: ch = JP_i BasicBlock:ch< 0x4afa8c8>, t30


Total amount of phi nodes to update: 0
Initial selection DAG: BB#2 'strlen:'
SelectionDAG has 8 nodes:
  t0: ch = EntryToken
  t2: i32 = Constant<0>
    t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4
  t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1



Combining: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

Combining: t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

Combining: t5: i32 = Register %R0

Combining: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Combining: t3: i32 = undef

Combining: t1: i32 = FrameIndex<1>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: BB#2 'strlen:'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
    t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4
  t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1


Legally typed node: t5: i32 = Register %R0

Legally typed node: t3: i32 = undef

Legally typed node: t1: i32 = FrameIndex<1>

Legally typed node: t0: ch = EntryToken

Legally typed node: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Legally typed node: t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

Legally typed node: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

Legally typed node: t65535: ch = handlenode t7

Type-legalized selection DAG: BB#2 'strlen:'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
    t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4
  t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1



Legalizing: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

Legalizing: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Legalizing: t5: i32 = Register %R0

Legalizing: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<1>

Legalizing: t0: ch = EntryToken
Legalized selection DAG: BB#2 'strlen:'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
    t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4
  t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1



Legalizing: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

Combining: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

Legalizing: t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

Combining: t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

Legalizing: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Combining: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

Legalizing: t5: i32 = Register %R0

Combining: t5: i32 = Register %R0

Legalizing: t3: i32 = undef

Combining: t3: i32 = undef

Legalizing: t1: i32 = FrameIndex<1>

Combining: t1: i32 = FrameIndex<1>

Legalizing: t0: ch = EntryToken

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: BB#2 'strlen:'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
    t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32
  t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4
  t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1


===== Instruction selection begins: BB#2 ''
Selecting: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

ISEL: Starting pattern match on root node: t7: ch = FRISCISD::RET_FLAG t6, Register:i32 %R0, t6:1

  Initial Opcode index to 947
  Morphed node: t7: ch = RET_uc Register:i32 %R0, t6, t6:1

ISEL: Match complete!
Selecting: t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

Selecting: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

ISEL: Starting pattern match on root node: t4: i32,ch = load<LD4[%3](dereferenceable)> t0, FrameIndex:i32<1>, undef:i32

  Initial Opcode index to 127
  Skipped scope entry (due to false predicate) at index 136, continuing at 170
  Morphed node: t4: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

ISEL: Match complete!
Selecting: t5: i32 = Register %R0

Selecting: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: BB#2 'strlen:'
SelectionDAG has 7 nodes:
  t0: ch = EntryToken
    t4: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0
  t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4
  t7: ch = RET_uc Register:i32 %R0, t6, t6:1


********** List Scheduling BB#2 '' **********
SU(0): t7: ch = RET_uc Register:i32 %R0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t4: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t7: ch = RET_uc Register:i32 %R0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4


*** Scheduling [0]: SU(0): t7: ch = RET_uc Register:i32 %R0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4

GPR: 1 / 0

Examining Available:
Height 1: SU(1): t4: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0


*** Scheduling [1]: SU(1): t4: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

*** Final schedule ***
SU(1): t4: i32,ch = LOAD_ri<Mem:LD4[%3](dereferenceable)> TargetFrameIndex:i32<1>, TargetConstant:i32<0>, t0

SU(0): t7: ch = RET_uc Register:i32 %R0, t6, t6:1

    t6: ch,glue = CopyToReg t0, Register:i32 %R0, t4


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function strlen: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: %R0 in %vreg0

BB#0: derived from LLVM BB %1
    Live Ins: %R0
	%vreg0<def> = COPY %R0; GPR:%vreg0
	%vreg1<def> = MOVE_ri 0; GPR:%vreg1
	STORE_ri <fi#1>, 0, %vreg1<kill>; mem:ST4[%3] GPR:%vreg1
	STORE_ri <fi#0>, 0, %vreg0; mem:ST4[%2] GPR:%vreg0
    Successors according to CFG: BB#1(?%)

BB#1: derived from LLVM BB %4
    Predecessors according to CFG: BB#0 BB#1
	%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
	%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
	STORE_ri <fi#1>, 0, %vreg3<kill>; mem:ST4[%3] GPR:%vreg3
	%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
	%vreg5<def> = ADD_rr %vreg4<kill>, %vreg2, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
	%vreg6<def> = LOADB_ri %vreg5<kill>, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
	%vreg7<def> = SHL_ri %vreg6<kill>, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
	%vreg8<def> = ASHR_ri %vreg7<kill>, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
	%vreg9<def> = MOVE_ri 0; GPR:%vreg9
	CMP_rr %vreg8<kill>, %vreg9<kill>, %SR<imp-def>; GPR:%vreg8,%vreg9
	JPcc_i <BB#1>, 8, %SR<imp-use>
	JP_i <BB#2>
    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)

BB#2: derived from LLVM BB %12
    Predecessors according to CFG: BB#1
	%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
	%R0<def> = COPY %vreg10; GPR:%vreg10
	RET_uc %SP<imp-use>, %R0<imp-use>

# End machine code for function strlen.

# Machine code for function strlen: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %1
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; GPR:%vreg0
32B		%vreg1<def> = MOVE_ri 0; GPR:%vreg1
48B		STORE_ri <fi#1>, 0, %vreg1<kill>; mem:ST4[%3] GPR:%vreg1
64B		STORE_ri <fi#0>, 0, %vreg0; mem:ST4[%2] GPR:%vreg0
	    Successors according to CFG: BB#1(?%)

80B	BB#1: derived from LLVM BB %4
	    Predecessors according to CFG: BB#0 BB#1
96B		%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
112B		%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
128B		STORE_ri <fi#1>, 0, %vreg3<kill>; mem:ST4[%3] GPR:%vreg3
144B		%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
160B		%vreg5<def> = ADD_rr %vreg4<kill>, %vreg2, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
176B		%vreg6<def> = LOADB_ri %vreg5<kill>, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
192B		%vreg7<def> = SHL_ri %vreg6<kill>, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
208B		%vreg8<def> = ASHR_ri %vreg7<kill>, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
224B		%vreg9<def> = MOVE_ri 0; GPR:%vreg9
240B		CMP_rr %vreg8<kill>, %vreg9<kill>, %SR<imp-def>; GPR:%vreg8,%vreg9
256B		JPcc_i <BB#1>, 8, %SR<imp-use>
272B		JP_i <BB#2>
	    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)

288B	BB#2: derived from LLVM BB %12
	    Predecessors according to CFG: BB#1
304B		%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
320B		%R0<def> = COPY %vreg10; GPR:%vreg10
336B		RET_uc %SP<imp-use>, %R0<imp-use>

# End machine code for function strlen.

********** Stack Coloring **********
********** Function: strlen
Found 0 markers and 2 slots
Slot structure:
Slot #0 - 4 bytes.
Slot #1 - 4 bytes.
Total Stack size: 8 bytes

Will not try to merge slots.
Removed 0 markers.
	discovered a new reachable node BB#0
	discovered a new reachable node BB#1
	discovered a new reachable node BB#2
******** Pre-regalloc Machine LICM: strlen ********
Entering BB#1
Can't remat / high reg-pressure: %vreg9<def> = MOVE_ri 0; GPR:%vreg9
Entering: 
Entering: 
Examining: %vreg9<def> = MOVE_ri 0; GPR:%vreg9
*** Found a common subexpression: %vreg1<def> = MOVE_ri 0; GPR:%vreg1
Entering: 
Exiting: 
Exiting: 
Exiting: 
	discovered a new reachable node BB#2
	discovered a new reachable node BB#1
	discovered a new reachable node BB#0
	discovered a new reachable node BB#0
	discovered a new reachable node BB#1
	discovered a new reachable node BB#2
	discovered a new reachable node BB#2
	discovered a new reachable node BB#1
	discovered a new reachable node BB#0

block-frequency: strlen
=======================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[]
 - 2: BB2[]
loop-detection
 - loop = BB1[]
compute-mass-in-loop: BB1[]*
 - node: BB1[]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[]
compute-loop-scale: BB1[]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[]*
 - node: BB1[]
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 2147483648, succ = BB1[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[]
 - node: BB1[]
  => [ local  ] weight = 576460752303423488, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[]
 - node: BB2[]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
 - BB1[]: float = 32.0, scaled = 256.0, int = 255
 - BB2[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: strlen
 - BB0[]: float = 1.0, int = 8
 - BB1[]: float = 32.0, int = 255
 - BB2[]: float = 1.0, int = 8

******** Machine Sinking ********
********** PEEPHOLE OPTIMIZER **********
********** Function: strlen
Encountered load fold barrier on STORE_ri <fi#1>, 0, %vreg1; mem:ST4[%3] GPR:%vreg1

Encountered load fold barrier on STORE_ri <fi#0>, 0, %vreg0; mem:ST4[%2] GPR:%vreg0

Encountered load fold barrier on STORE_ri <fi#1>, 0, %vreg3<kill>; mem:ST4[%3] GPR:%vreg3

Skipping Detect dead lanes pass
********** PROCESS IMPLICIT DEFS **********
********** Function: strlen
********** REWRITING TWO-ADDR INSTRS **********
********** Function: strlen
# Machine code for function strlen: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %1
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0<kill>; GPR:%vreg0
32B		%vreg1<def> = MOVE_ri 0; GPR:%vreg1
48B		STORE_ri <fi#1>, 0, %vreg1; mem:ST4[%3] GPR:%vreg1
64B		STORE_ri <fi#0>, 0, %vreg0<kill>; mem:ST4[%2] GPR:%vreg0
	    Successors according to CFG: BB#1(?%)

80B	BB#1: derived from LLVM BB %4
	    Predecessors according to CFG: BB#0 BB#1
96B		%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
112B		%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
128B		STORE_ri <fi#1>, 0, %vreg3<kill>; mem:ST4[%3] GPR:%vreg3
144B		%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
160B		%vreg5<def> = ADD_rr %vreg4<kill>, %vreg2<kill>, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
176B		%vreg6<def> = LOADB_ri %vreg5<kill>, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
192B		%vreg7<def> = SHL_ri %vreg6<kill>, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
208B		%vreg8<def> = ASHR_ri %vreg7<kill>, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
224B		CMP_rr %vreg8<kill>, %vreg1, %SR<imp-def>; GPR:%vreg8,%vreg1
240B		JPcc_i <BB#1>, 8, %SR<imp-use>
256B		JP_i <BB#2>
	    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)

272B	BB#2: derived from LLVM BB %12
	    Predecessors according to CFG: BB#1
288B		%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
304B		%R0<def> = COPY %vreg10<kill>; GPR:%vreg10
320B		RET_uc %SP<imp-use,kill>, %R0<imp-use,kill>

# End machine code for function strlen.

Computing live-in reg-units in ABI blocks.
0B	BB#0 R0#0
Created 1 new intervals.
********** INTERVALS **********
R0 [0B,16r:0)[304r,320r:1)  0@0B-phi 1@304r
%vreg0 [16r,64r:0)  0@16r
%vreg1 [32r,272B:0)  0@32r
%vreg2 [96r,160r:0)  0@96r
%vreg3 [112r,128r:0)  0@112r
%vreg4 [144r,160r:0)  0@144r
%vreg5 [160r,176r:0)  0@160r
%vreg6 [176r,192r:0)  0@176r
%vreg7 [192r,208r:0)  0@192r
%vreg8 [208r,224r:0)  0@208r
%vreg10 [288r,304r:0)  0@288r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function strlen: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %1
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; GPR:%vreg0
32B		%vreg1<def> = MOVE_ri 0; GPR:%vreg1
48B		STORE_ri <fi#1>, 0, %vreg1; mem:ST4[%3] GPR:%vreg1
64B		STORE_ri <fi#0>, 0, %vreg0; mem:ST4[%2] GPR:%vreg0
	    Successors according to CFG: BB#1(?%)

80B	BB#1: derived from LLVM BB %4
	    Predecessors according to CFG: BB#0 BB#1
96B		%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
112B		%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
128B		STORE_ri <fi#1>, 0, %vreg3; mem:ST4[%3] GPR:%vreg3
144B		%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
160B		%vreg5<def> = ADD_rr %vreg4, %vreg2, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
176B		%vreg6<def> = LOADB_ri %vreg5, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
192B		%vreg7<def> = SHL_ri %vreg6, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
208B		%vreg8<def> = ASHR_ri %vreg7, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
224B		CMP_rr %vreg8, %vreg1, %SR<imp-def>; GPR:%vreg8,%vreg1
240B		JPcc_i <BB#1>, 8, %SR<imp-use>
256B		JP_i <BB#2>
	    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)

272B	BB#2: derived from LLVM BB %12
	    Predecessors according to CFG: BB#1
288B		%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
304B		%R0<def> = COPY %vreg10; GPR:%vreg10
320B		RET_uc %SP<imp-use,kill>, %R0<imp-use>

# End machine code for function strlen.

********** SIMPLE REGISTER COALESCING **********
********** Function: strlen
********** JOINING INTERVALS ***********
:
:
16B	%vreg0<def> = COPY %R0; GPR:%vreg0
	Considering merging %vreg0 with %R0
	Can only merge into reserved registers.
:
304B	%R0<def> = COPY %vreg10; GPR:%vreg10
	Considering merging %vreg10 with %R0
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
R0 [0B,16r:0)[304r,320r:1)  0@0B-phi 1@304r
%vreg0 [16r,64r:0)  0@16r
%vreg1 [32r,272B:0)  0@32r
%vreg2 [96r,160r:0)  0@96r
%vreg3 [112r,128r:0)  0@112r
%vreg4 [144r,160r:0)  0@144r
%vreg5 [160r,176r:0)  0@160r
%vreg6 [176r,192r:0)  0@176r
%vreg7 [192r,208r:0)  0@192r
%vreg8 [208r,224r:0)  0@208r
%vreg10 [288r,304r:0)  0@288r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function strlen: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %1
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; GPR:%vreg0
32B		%vreg1<def> = MOVE_ri 0; GPR:%vreg1
48B		STORE_ri <fi#1>, 0, %vreg1; mem:ST4[%3] GPR:%vreg1
64B		STORE_ri <fi#0>, 0, %vreg0; mem:ST4[%2] GPR:%vreg0
	    Successors according to CFG: BB#1(?%)

80B	BB#1: derived from LLVM BB %4
	    Predecessors according to CFG: BB#0 BB#1
96B		%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
112B		%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
128B		STORE_ri <fi#1>, 0, %vreg3; mem:ST4[%3] GPR:%vreg3
144B		%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
160B		%vreg5<def> = ADD_rr %vreg4, %vreg2, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
176B		%vreg6<def> = LOADB_ri %vreg5, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
192B		%vreg7<def> = SHL_ri %vreg6, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
208B		%vreg8<def> = ASHR_ri %vreg7, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
224B		CMP_rr %vreg8, %vreg1, %SR<imp-def>; GPR:%vreg8,%vreg1
240B		JPcc_i <BB#1>, 8, %SR<imp-use>
256B		JP_i <BB#2>
	    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)

272B	BB#2: derived from LLVM BB %12
	    Predecessors according to CFG: BB#1
288B		%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
304B		%R0<def> = COPY %vreg10; GPR:%vreg10
320B		RET_uc %SP<imp-use,kill>, %R0<imp-use>

# End machine code for function strlen.


block-frequency: strlen
=======================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[]
 - 2: BB2[]
loop-detection
 - loop = BB1[]
compute-mass-in-loop: BB1[]*
 - node: BB1[]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[]
compute-loop-scale: BB1[]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[]*
 - node: BB1[]
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 2147483648, succ = BB1[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[]
 - node: BB1[]
  => [ local  ] weight = 576460752303423488, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[]
 - node: BB2[]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
 - BB1[]: float = 32.0, scaled = 256.0, int = 255
 - BB2[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: strlen
 - BB0[]: float = 1.0, int = 8
 - BB1[]: float = 32.0, int = 255
 - BB2[]: float = 1.0, int = 8

********** GREEDY REGISTER ALLOCATION **********
********** Function: strlen
********** Compute Spill Weights **********
********** Function: strlen
********** INTERVALS **********
R0 [0B,16r:0)[304r,320r:1)  0@0B-phi 1@304r
%vreg0 [16r,64r:0)  0@16r
%vreg1 [32r,272B:0)  0@32r
%vreg2 [96r,160r:0)  0@96r
%vreg3 [112r,128r:0)  0@112r
%vreg4 [144r,160r:0)  0@144r
%vreg5 [160r,176r:0)  0@160r
%vreg6 [176r,192r:0)  0@176r
%vreg7 [192r,208r:0)  0@192r
%vreg8 [208r,224r:0)  0@208r
%vreg10 [288r,304r:0)  0@288r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function strlen: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP]
  fi#1: size=4, align=4, at location [SP]
Function Live Ins: %R0 in %vreg0

0B	BB#0: derived from LLVM BB %1
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; GPR:%vreg0
32B		%vreg1<def> = MOVE_ri 0; GPR:%vreg1
48B		STORE_ri <fi#1>, 0, %vreg1; mem:ST4[%3] GPR:%vreg1
64B		STORE_ri <fi#0>, 0, %vreg0; mem:ST4[%2] GPR:%vreg0
	    Successors according to CFG: BB#1(?%)

80B	BB#1: derived from LLVM BB %4
	    Predecessors according to CFG: BB#0 BB#1
96B		%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
112B		%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
128B		STORE_ri <fi#1>, 0, %vreg3; mem:ST4[%3] GPR:%vreg3
144B		%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
160B		%vreg5<def> = ADD_rr %vreg4, %vreg2, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
176B		%vreg6<def> = LOADB_ri %vreg5, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
192B		%vreg7<def> = SHL_ri %vreg6, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
208B		%vreg8<def> = ASHR_ri %vreg7, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
224B		CMP_rr %vreg8, %vreg1, %SR<imp-def>; GPR:%vreg8,%vreg1
240B		JPcc_i <BB#1>, 8, %SR<imp-use>
256B		JP_i <BB#2>
	    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)

272B	BB#2: derived from LLVM BB %12
	    Predecessors according to CFG: BB#1
288B		%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
304B		%R0<def> = COPY %vreg10; GPR:%vreg10
320B		RET_uc %SP<imp-use,kill>, %R0<imp-use>

# End machine code for function strlen.


selectOrSplit GPR:%vreg0 [16r,64r:0)  0@16r w=4.508928e-03
AllocationOrder(GPR) = [ %R0 %R1 %R2 %R3 %R4 %R5 %R6 %SP ]
hints: %R0
assigning %vreg0 to %R0: R0 [16r,64r:0)  0@16r

selectOrSplit GPR:%vreg10 [288r,304r:0)  0@288r w=INF
hints: %R0
assigning %vreg10 to %R0: R0 [288r,304r:0)  0@288r

selectOrSplit GPR:%vreg1 [32r,272B:0)  0@32r w=5.309561e-02
assigning %vreg1 to %R1: R1 [32r,272B:0)  0@32r

selectOrSplit GPR:%vreg2 [96r,160r:0)  0@96r w=2.060884e-01
assigning %vreg2 to %R0: R0 [96r,160r:0)  0@96r

selectOrSplit GPR:%vreg3 [112r,128r:0)  0@112r w=INF
assigning %vreg3 to %R2: R2 [112r,128r:0)  0@112r

selectOrSplit GPR:%vreg4 [144r,160r:0)  0@144r w=INF
assigning %vreg4 to %R2: R2 [144r,160r:0)  0@144r

selectOrSplit GPR:%vreg5 [160r,176r:0)  0@160r w=INF
assigning %vreg5 to %R0: R0 [160r,176r:0)  0@160r

selectOrSplit GPR:%vreg6 [176r,192r:0)  0@176r w=INF
assigning %vreg6 to %R0: R0 [176r,192r:0)  0@176r

selectOrSplit GPR:%vreg7 [192r,208r:0)  0@192r w=INF
assigning %vreg7 to %R0: R0 [192r,208r:0)  0@192r

selectOrSplit GPR:%vreg8 [208r,224r:0)  0@208r w=INF
assigning %vreg8 to %R0: R0 [208r,224r:0)  0@208r
********** REWRITE VIRTUAL REGISTERS **********
********** Function: strlen
********** REGISTER MAP **********
[%vreg0 -> %R0] GPR
[%vreg1 -> %R1] GPR
[%vreg2 -> %R0] GPR
[%vreg3 -> %R2] GPR
[%vreg4 -> %R2] GPR
[%vreg5 -> %R0] GPR
[%vreg6 -> %R0] GPR
[%vreg7 -> %R0] GPR
[%vreg8 -> %R0] GPR
[%vreg10 -> %R0] GPR

0B	BB#0: derived from LLVM BB %1
	    Live Ins: %R0
16B		%vreg0<def> = COPY %R0; GPR:%vreg0
32B		%vreg1<def> = MOVE_ri 0; GPR:%vreg1
48B		STORE_ri <fi#1>, 0, %vreg1; mem:ST4[%3] GPR:%vreg1
64B		STORE_ri <fi#0>, 0, %vreg0<kill>; mem:ST4[%2] GPR:%vreg0
	    Successors according to CFG: BB#1(?%)
> %R0<def> = COPY %R0
Identity copy: %R0<def> = COPY %R0
  deleted.
> %R1<def> = MOVE_ri 0
> STORE_ri <fi#1>, 0, %R1; mem:ST4[%3]
> STORE_ri <fi#0>, 0, %R0<kill>; mem:ST4[%2]
80B	BB#1: derived from LLVM BB %4
	    Live Ins: %R1
	    Predecessors according to CFG: BB#0 BB#1
96B		%vreg2<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg2
112B		%vreg3<def> = ADD_ri %vreg2, 1, %SR<imp-def,dead>; GPR:%vreg3,%vreg2
128B		STORE_ri <fi#1>, 0, %vreg3<kill>; mem:ST4[%3] GPR:%vreg3
144B		%vreg4<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable) GPR:%vreg4
160B		%vreg5<def> = ADD_rr %vreg4<kill>, %vreg2<kill>, %SR<imp-def,dead>; GPR:%vreg5,%vreg4,%vreg2
176B		%vreg6<def> = LOADB_ri %vreg5<kill>, 0; mem:LD1[%8] GPR:%vreg6,%vreg5
192B		%vreg7<def> = SHL_ri %vreg6<kill>, 24, %SR<imp-def,dead>; GPR:%vreg7,%vreg6
208B		%vreg8<def> = ASHR_ri %vreg7<kill>, 24, %SR<imp-def,dead>; GPR:%vreg8,%vreg7
224B		CMP_rr %vreg8<kill>, %vreg1, %SR<imp-def>; GPR:%vreg8,%vreg1
240B		JPcc_i <BB#1>, 8, %SR<imp-use>
256B		JP_i <BB#2>
	    Successors according to CFG: BB#1(0x7c000000 / 0x80000000 = 96.88%) BB#2(0x04000000 / 0x80000000 = 3.12%)
> %R0<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable)
> %R2<def> = ADD_ri %R0, 1, %SR<imp-def,dead>
> STORE_ri <fi#1>, 0, %R2<kill>; mem:ST4[%3]
> %R2<def> = LOAD_ri <fi#0>, 0; mem:LD4[%2](dereferenceable)
> %R0<def> = ADD_rr %R2<kill>, %R0<kill>, %SR<imp-def,dead>
> %R0<def> = LOADB_ri %R0<kill>, 0; mem:LD1[%8]
> %R0<def> = SHL_ri %R0<kill>, 24, %SR<imp-def,dead>
> %R0<def> = ASHR_ri %R0<kill>, 24, %SR<imp-def,dead>
> CMP_rr %R0<kill>, %R1, %SR<imp-def>
> JPcc_i <BB#1>, 8, %SR<imp-use>
> JP_i <BB#2>
272B	BB#2: derived from LLVM BB %12
	    Predecessors according to CFG: BB#1
288B		%vreg10<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable) GPR:%vreg10
304B		%R0<def> = COPY %vreg10<kill>; GPR:%vreg10
320B		RET_uc %SP<imp-use,kill>, %R0<imp-use>
> %R0<def> = LOAD_ri <fi#1>, 0; mem:LD4[%3](dereferenceable)
> %R0<def> = COPY %R0<kill>
Identity copy: %R0<def> = COPY %R0<kill>
  deleted.
> RET_uc %SP<imp-use,kill>, %R0<imp-use>
********** Stack Slot Coloring **********
********** Function: strlen
******** Post-regalloc Machine LICM: strlen ********

block-frequency: strlen
=======================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[]
 - 2: BB2[]
loop-detection
 - loop = BB1[]
compute-mass-in-loop: BB1[]*
 - node: BB1[]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[]
compute-loop-scale: BB1[]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[]*
 - node: BB1[]
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 2147483648, succ = BB1[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[]
 - node: BB1[]
  => [ local  ] weight = 576460752303423488, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[]
 - node: BB2[]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
 - BB1[]: float = 32.0, scaled = 256.0, int = 255
 - BB2[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: strlen
 - BB0[]: float = 1.0, int = 8
 - BB1[]: float = 32.0, int = 255
 - BB2[]: float = 1.0, int = 8

	discovered a new reachable node BB#2
	discovered a new reachable node BB#1
	discovered a new reachable node BB#0
alloc FI(2) at SP[-8]
alloc FI(0) at SP[-12]
alloc FI(1) at SP[-16]
MCP: CopyPropagateBlock 
MCP: CopyPropagateBlock 
MCP: CopyPropagateBlock 
Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: strlen
	discovered a new reachable node BB#0
	discovered a new reachable node BB#1
	discovered a new reachable node BB#2

block-frequency: strlen
=======================
reverse-post-order-traversal
 - 0: BB0[]
 - 1: BB1[]
 - 2: BB2[]
loop-detection
 - loop = BB1[]
compute-mass-in-loop: BB1[]*
 - node: BB1[]
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB1[]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[]
compute-loop-scale: BB1[]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB1[]*
 - node: BB1[]
compute-mass-in-function
 - node: BB0[]
  => [ local  ] weight = 2147483648, succ = BB1[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB1[]
 - node: BB1[]
  => [ local  ] weight = 576460752303423488, succ = BB2[]
  => mass:  ffffffffffffffff
  => assign ffffffffffffffff (0000000000000000) to BB2[]
 - node: BB2[]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB1[]*: mass = ffffffffffffffff, scale = 32.0
  => combined-scale = 32.0
 - BB1[]: 1.0 => 32.0
float-to-int: min = 1.0, max = 32.0, factor = 8.0
 - BB0[]: float = 1.0, scaled = 8.0, int = 8
 - BB1[]: float = 32.0, scaled = 256.0, int = 255
 - BB2[]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: strlen
 - BB0[]: float = 1.0, int = 8
 - BB1[]: float = 32.0, int = 255
 - BB2[]: float = 1.0, int = 8

	discovered a new reachable node BB#2
	discovered a new reachable node BB#1
	discovered a new reachable node BB#0
Pre-computing triangle chains.
Finding best loop top for: BB#1 ('')
    header pred: BB#1 (''), has 2 successors, 31.875 freq
    final top unchanged
Finding best loop exit for: BB#1 ('')
    exiting: BB#1 ('') -> BB#2 ('') [L:0] (0.875)
    No other candidate exit blocks, using loop header
Selecting best successor for: BB#1 ('')
Finished forming chain for header block BB#1 ('')
          ... BB#1 ('')
Selecting best successor for: BB#0 ('')
    Candidate: BB#1 (''), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: BB#1 ('')
Merging from BB#0 ('') to BB#1 ('')
Selecting best successor for: BB#1 ('')
    Candidate: BB#2 (''), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: BB#2 ('')
Merging from BB#1 ('') to BB#2 ('')
Selecting best successor for: BB#2 ('')
Finished forming chain for header block BB#0 ('')
[MBP] Function: strlen
Placing chain BB#0 ('')
          ... BB#1 ('')
          ... BB#2 ('')
********** COMPUTING STACKMAP LIVENESS: strlen **********
	discovered a new reachable node BB#0
	discovered a new reachable node BB#1
	discovered a new reachable node BB#2
	discovered a new reachable node BB#0
	discovered a new reachable node BB#1
	discovered a new reachable node BB#2
